package daemon

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"

	ign3types "github.com/coreos/ignition/v2/config/v3_4/types"
	"github.com/openshift/machine-config-operator/pkg/daemon/osrelease"
	"github.com/redhat-et/transmission/pkg/ignition"
	"k8s.io/klog/v2"
)

type Daemon struct {
	// os the operating system the MCD is running on
	os osrelease.OperatingSystem

	// mock is set if we're running as non-root, probably under unit tests
	mock bool

	// bootID is a unique value per boot (generated by the kernel)
	bootID string

	// channel used by callbacks to signal Run() of an error
	exitCh chan<- error

	// channel used to ensure all spawned goroutines exit when we exit.
	stopCh <-chan struct{}

	// directory to use for storing application configuration (e.g. configsets, backup files, etc.)
	configDir string

	// directory to use as file system root
	rootDir string
}

var (
	// configSetDirPath is where Transmission stores its configsets
	configSetDirName = "configsets"

	// desiredConfigSetFilename is the file name of the desired configset
	desiredConfigSetFilename = "desired.ign"

	// currentConfigSetFilename is the file name of the current configset
	currentConfigSetFilename = "current.ign"

	// previousConfigSetFilename is the file name of the previous configset
	previousConfigSetFilename = "previous.ign"

	// pathSystemd is the path systemd modifiable units, services, etc.. reside
	pathSystemd = "/etc/systemd/system"
	// pathDevNull is the systems path to and endless blackhole
	pathDevNull = "/dev/null"

	// used for certificate syncing
	caBundleFilePath = "/etc/kubernetes/kubelet-ca.crt"
)

func New(
	exitCh chan<- error,
	configDir string,
	rootDir string,
	mock bool,
) (*Daemon, error) {
	dn := &Daemon{
		mock:      mock,
		os:        osrelease.OperatingSystem{},
		bootID:    "",
		exitCh:    exitCh,
		configDir: configDir,
		rootDir:   rootDir,
	}

	if err := os.MkdirAll(filepath.Dir(dn.CurrentConfigSet()), 0755); err != nil {
		return nil, err
	}
	if err := ignition.EnsureExists(dn.CurrentConfigSet()); err != nil {
		return nil, err
	}

	if !mock {
		var err error
		dn.os, err = osrelease.GetHostRunningOS()
		if err != nil {
			return nil, fmt.Errorf("checking operating system: %w", err)
		}
		// 	dn.bootID, err = getBootID()
		// 	if err != nil {
		// 		return nil, fmt.Errorf("failed to read boot ID: %w", err)
		// 	}
	}
	return dn, nil
}

func (dn *Daemon) DesiredConfigSet() string {
	return filepath.Join(dn.configDir, configSetDirName, desiredConfigSetFilename)
}

func (dn *Daemon) CurrentConfigSet() string {
	return filepath.Join(dn.configDir, configSetDirName, currentConfigSetFilename)
}

func (dn *Daemon) PreviousConfigSetPath() string {
	return filepath.Join(dn.configDir, configSetDirName, previousConfigSetFilename)
}

// type unreconcilableErr struct {
// 	error
// }

// storeCurrentConfigOnDisk serializes a machine config into a file in /etc,
// which we use to denote that we are expecting the system has transitioned
// into this state.
func (dn *Daemon) storeCurrentConfigOnDisk(current *ign3types.Config) error {
	ign, err := json.Marshal(current)
	if err != nil {
		return err
	}
	if os.Rename(dn.CurrentConfigSet(), dn.PreviousConfigSetPath()) != nil {
		klog.Warningf("failed to rename %s to %s: %w", dn.CurrentConfigSet(), dn.PreviousConfigSetPath(), err)
	}
	return writeFileAtomicallyWithDefaults(dn.CurrentConfigSet(), ign)
}
